% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pivot-long.R
\name{pivot_longer}
\alias{pivot_longer}
\alias{pivot_longer_spec}
\title{Pivot data from wide to long.}
\usage{
pivot_longer(df, cols, names_to = "name", names_prefix = NULL,
  names_sep = NULL, names_pattern = NULL, values_to = "value",
  values_drop_na = FALSE, col_ptypes = list(), spec = NULL)

pivot_longer_spec(df, cols, names_to = "name", values_to = "value",
  names_prefix = NULL, names_sep = NULL, names_pattern = NULL,
  col_ptypes = NULL)
}
\arguments{
\item{df}{A data frame to pivot.}

\item{cols}{Columns to pivot into longer format. This takes a tidyselect
specification.}

\item{names_to, values_to}{This pair of arguments determine which columns
the data stored in the column names (\code{names_to}) and the data stored in
the cell values (\code{values_to}) turn into in the result.

Note that these variables do not exist, so must be specified as strings.

If \code{names_to} contains multiple columns (i.e., \code{c(".value", "time")}),
you won't need to specify \code{values_to} because the special variable name
\code{.value} defines the name of the output value columns.}

\item{names_prefix}{A regular expression used to remove matching text
from the start of each variable name.}

\item{names_sep, names_pattern}{If \code{names_to} contains multiple values,
these arguments control how the column name is broken up.

\code{names_sep} takes the same specification as \code{\link[=separate]{separate()}}, and can either
be a numeric vector (specifying positions to break on), or a single string
(specifying a regular expression to split on).

\code{names_pattern} takes the same specification as \code{\link[=extract]{extract()}}, a regular
expression containing matching groups (\code{()}).

If these arguments does not give you enough control, use
\code{pivot_longer_spec()} to create a spec object and process manually as
needed.}

\item{values_drop_na}{If \code{TRUE}, will drop rows that contain only \code{NA}s
in the \code{value_to} column. This effectively converts explicit missing values
to implicit missing values, and should generally be used only when missing
values in \code{df} were created by its structure.}

\item{col_ptypes}{A list of of column name-prototype pairs.

If not specified, the type of the generated from \code{names_to} will be
character, and the type of the variables generated from \code{values_to}
will be the common type of the input columns used to generate them.}

\item{spec}{Alternatively, instead of providing \code{cols} (and \code{names_to} and
\code{values_to}) you can parse a specification data frame. This is useful
for more complex pivots because it gives you greater control on how
metadata stored in the column names turns into columns in the result.

Must be a data frame containing character \code{.name} and \code{.value} columns.}
}
\description{
\code{pivot_longer()} "lengthens" data, increasing the number of rows and
decreasing the number of columns. See more details in \code{vignette("pivot")},
and see \code{\link[=pivot_wider]{pivot_wider()}} for the inverse transformation.
}
